from flask import Flask, request, jsonify, make_response
from flask_restplus import Api, Resource, fields
import joblib
import pefile
import  csv
import pandas as pd
import numpy as np
import pefile

flask_app = Flask(__name__)
app = Api(app = flask_app,
		  version = "1.0",
		  title = "ML React App",
		  description = "Predict results using a trained model")

name_space = app.namespace('prediction', description='Prediction APIs')

model = app.model('Prediction params',
				  {'textField1': fields.String(required = True,
				  							   description="Text Field 1",
    					  				 	   help="Text Field 1 cannot be blank")})

@name_space.route("/")
class MainClass(Resource):

	def options(self):
		response = make_response()
		response.headers.add("Access-Control-Allow-Origin", "*")
		response.headers.add('Access-Control-Allow-Headers', "*")
		response.headers.add('Access-Control-Allow-Methods', "*")
		return response

	@app.expect(model)
	def post(self):
		try:
			formData = request.json
			# name = "C:/Users/kriti/Downloads/" + JSON.stringify(formData)
			name = "C:/Users/kriti/Downloads/ZoomInstaller.exe"
			pe = pefile.PE(name)
			classifier  = []
			for i in range(5):
				classifier.append(joblib.load('C:/Kritika/MiniProject/Code/service/pipeline'+str(i + 1) + '.joblib'))
			data = [pe.DOS_HEADER.e_cblp, pe.DOS_HEADER.e_cp, pe.DOS_HEADER.e_crlc, pe.DOS_HEADER.e_cparhdr, pe.DOS_HEADER.e_minalloc, pe.DOS_HEADER.e_maxalloc, pe.DOS_HEADER.e_ss, pe.DOS_HEADER.e_sp, pe.DOS_HEADER.e_csum, pe.DOS_HEADER.e_ip, pe.DOS_HEADER.e_cs, pe.DOS_HEADER.e_lfarlc, pe.DOS_HEADER.e_ovno, pe.DOS_HEADER.e_oemid,pe.DOS_HEADER.e_oeminfo, pe.DOS_HEADER.e_lfanew, pe.FILE_HEADER.Machine, pe.FILE_HEADER.NumberOfSections, pe.FILE_HEADER.TimeDateStamp, pe.FILE_HEADER.PointerToSymbolTable, pe.FILE_HEADER.NumberOfSymbols, pe.FILE_HEADER.SizeOfOptionalHeader, pe.FILE_HEADER.Characteristics, pe.OPTIONAL_HEADER.Magic, pe.OPTIONAL_HEADER.MajorLinkerVersion, pe.OPTIONAL_HEADER.MinorLinkerVersion, pe.OPTIONAL_HEADER.SizeOfCode, pe.OPTIONAL_HEADER.SizeOfInitializedData, pe.OPTIONAL_HEADER.SizeOfUninitializedData, pe.OPTIONAL_HEADER.AddressOfEntryPoint, pe.OPTIONAL_HEADER.BaseOfCode, pe.OPTIONAL_HEADER.ImageBase, pe.OPTIONAL_HEADER.SectionAlignment, pe.OPTIONAL_HEADER.SectionAlignment, pe.OPTIONAL_HEADER.FileAlignment, pe.OPTIONAL_HEADER.MajorOperatingSystemVersion, pe.OPTIONAL_HEADER.MajorImageVersion, pe.OPTIONAL_HEADER.MinorImageVersion, pe.OPTIONAL_HEADER.MajorSubsystemVersion, pe.OPTIONAL_HEADER.MinorSubsystemVersion, pe.OPTIONAL_HEADER.SizeOfHeaders, pe.OPTIONAL_HEADER.CheckSum, pe.OPTIONAL_HEADER.SizeOfImage, pe.OPTIONAL_HEADER.Subsystem, pe.OPTIONAL_HEADER.DllCharacteristics,pe.OPTIONAL_HEADER.SizeOfStackReserve, pe.OPTIONAL_HEADER.SizeOfStackCommit, pe.OPTIONAL_HEADER.SizeOfHeapReserve, pe.OPTIONAL_HEADER.SizeOfHeapCommit, pe.OPTIONAL_HEADER.LoaderFlags, pe.OPTIONAL_HEADER.NumberOfRvaAndSizes,17,5,2.39294,0,1024,831,46822,90112,68096,3.22E+09,5,169,0,pe.OPTIONAL_HEADER.DATA_DIRECTORY[0].Size, pe.OPTIONAL_HEADER.DATA_DIRECTORY[1].Size, pe.OPTIONAL_HEADER.DATA_DIRECTORY[2].Size, pe.OPTIONAL_HEADER.DATA_DIRECTORY[3].Size, pe.OPTIONAL_HEADER.DATA_DIRECTORY[4].Size]

			prediction = [classify.predict(np.array(data).reshape(1, -1))[0] for classify in classifier]


			types = { 0: "Benign", 1: "Malware"}
			response = jsonify({
				"statusCode": 200,
				"status": "Prediction made",
				"result1": "Naive Bayes predicted: " + types[prediction[0]],
				"result2": "Decision Tree predicted: " + types[prediction[1]],
				"result3": "KNN predicted: " + types[prediction[2]],
				"result4": "SVM predicted: " + types[prediction[3]],
				"result5": "Random Forest predicted: " + types[prediction[4]],
				})
			response.headers.add('Access-Control-Allow-Origin', '*')
			return response
		except Exception as error:
			return jsonify({
				"statusCode": 500,
				"status": "Could not make prediction",
				"error": str(error)
			})
